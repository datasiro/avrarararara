<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAI PNG 메타데이터 제거기 (자동/수동/ZIP 지원)</title>
  <style>
    :root{
      --bg:#0b0f14;--card:#121823;--muted:#2a3340;--text:#eaf2ff;--sub:#9fb2cc;--accent:#7aa2ff;--ok:#38d39f;--warn:#ffcf5a;--err:#ff6b6b
    }
    *{box-sizing:border-box}body{margin:0;background:linear-gradient(180deg,#0b0f14,#0e1219 50%,#0b0f14);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Helvetica,Arial}
    header{padding:28px 20px 10px;text-align:center}
    h1{font-size:24px;margin:0 0 8px}p.lead{margin:0;color:var(--sub)}
    .wrap{max-width:940px;margin:16px auto 40px;padding:0 16px}
    .card{background:var(--card);border:1px solid #162233;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.25);overflow:hidden}
    .toolbar{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--muted)}
    .left, .right{display:flex;gap:12px;align-items:center}
    .btn{appearance:none;border:1px solid var(--muted);background:#101827;color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .btn:hover{border-color:#395070}
    .btn.primary{background:var(--accent);border-color:var(--accent);color:#051028}
    .btn.primary:disabled{opacity:.5;cursor:not-allowed}
    .drop{padding:18px;border:2px dashed #324056;border-radius:14px;margin:16px;background:#0e1520;text-align:center;color:var(--sub)}
    .drop.dragover{border-color:var(--accent);color:var(--accent)}
    .list{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px;padding:16px}
    .item{background:#0d1420;border:1px solid #1c2a3d;border-radius:14px;overflow:hidden;display:flex;flex-direction:column}
    .thumb{display:block;width:100%;height:140px;object-fit:cover;background:#0a111b}
    .meta{padding:6px 8px;font-size:12px;color:var(--sub);display:flex;justify-content:space-between;align-items:center}
    .actions{padding:6px 8px;display:flex;gap:6px;justify-content:flex-end}
    .log{padding:12px 16px;border-top:1px solid var(--muted);max-height:160px;overflow:auto;font-family:ui-monospace,Consolas,Menlo,monospace;font-size:12px;background:#0c1320}
    .ok{color:var(--ok)}.warn{color:var(--warn)}.err{color:var(--err)}
    footer{max-width:940px;margin:16px auto 40px;padding:0 16px;color:var(--sub);text-align:center}
    a{color:var(--accent)}
    input.nameprefix{padding:10px 12px;border-radius:12px;border:1px solid var(--muted);background:#101827;color:var(--text);min-width:120px}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
  <header>
    <h1>NAI PNG 메타데이터 제거기</h1>
    <p class="lead">NovelAI 등에서 받은 PNG의 메타데이터를 <b>확장 스크립트와 동일한 방식</b>(캔버스 재인코딩 → 임시 JPEG → 최종 포맷)으로 제거합니다.<br/>자동 다운로드 / 개별 다운로드 버튼 / ZIP 다운로드 모두 지원합니다.</p>
  </header>
  <div class="wrap">
    <div class="card">
      <div class="toolbar">
        <div class="left">
          <label class="btn">
            파일 선택
            <input id="file-input" type="file" accept="image/*" multiple hidden />
          </label>
          <button id="clear" class="btn" type="button">초기화</button>
          <input id="name-prefix" class="nameprefix" type="text" placeholder="파일명 접두어 (기본: 숫자만)" />
        </div>
        <div class="right" style="flex-wrap:wrap;gap:6px">
          <label>저장 포맷
            <select id="out-format" class="btn" style="padding-right:32px">
              <option value="png" selected>PNG (권장)</option>
              <option value="jpeg">JPEG</option>
              <option value="webp">WEBP</option>
            </select>
          </label>
          <button id="process-list" class="btn primary" type="button">처리 (목록에 추가)</button>
          <button id="process-auto" class="btn" type="button">자동 다운로드</button>
          <button id="process-zip" class="btn" type="button">ZIP 다운로드</button>
        </div>
      </div>

      <div id="drop" class="drop">여기에 이미지를 드래그 앤 드롭하거나, 상단의 <b>파일 선택</b>을 눌러주세요.</div>
      <div id="list" class="list"></div>
      <pre id="log" class="log"></pre>
    </div>
  </div>

  <footer>
    <p>GitHub Pages에 그대로 올리면 동작합니다. 모든 처리는 <b>브라우저 로컬</b>에서 수행됩니다.</p>
  </footer>

  <script>
  if (!HTMLCanvasElement.prototype.toBlob) {
    HTMLCanvasElement.prototype.toBlob = function(callback, type, quality) {
      const dataURL = this.toDataURL(type, quality);
      const binStr = atob(dataURL.split(',')[1]);
      const len = binStr.length;
      const arr = new Uint8Array(len);
      for (let i = 0; i < len; i++) arr[i] = binStr.charCodeAt(i);
      callback(new Blob([arr], { type: type || 'image/png' }));
    };
  }

  const state = { files: [], counterStart: 1, results: [] }
  const el = (id)=>document.getElementById(id);
  const $drop = el('drop'), $list=el('list'), $log=el('log');

  function log(msg, cls=""){
    const line = document.createElement('div');
    if(cls) line.className = cls;
    line.textContent = msg;
    $log.appendChild(line);
    $log.scrollTop = $log.scrollHeight;
  }

  function renderList(){
    $list.innerHTML = '';
    if(state.results.length===0){
      $list.innerHTML = '<div class="item" style="display:flex;align-items:center;justify-content:center;height:140px;color:var(--sub)">처리된 이미지가 없습니다.</div>'
      return;
    }
    state.results.forEach(r=>{
      const card = document.createElement('div');card.className='item';
      const img = document.createElement('img');img.className='thumb';
      img.src = URL.createObjectURL(r.blob);
      const meta = document.createElement('div');meta.className='meta';
      meta.innerHTML = `<span>${r.filename}</span><span>${(r.blob.size/1024).toFixed(1)} KB</span>`;
      const actions = document.createElement('div');actions.className='actions';
      const btn = document.createElement('a');
      btn.href = img.src; btn.download = r.filename; btn.className='btn'; btn.textContent='다운로드';
      actions.appendChild(btn);
      card.appendChild(img);card.appendChild(meta);card.appendChild(actions);
      $list.appendChild(card);
    })
  }

  function onFilesPicked(files){
    const imgs = [...files].filter(f=>f.type.startsWith('image/'));
    state.files.push(...imgs);
    log(`${imgs.length}개 이미지 추가됨.`,'ok');
  }

  function convertToBlob(sourceBlob, targetFormat, qualityPref='quality'){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      const url = URL.createObjectURL(sourceBlob);
      img.onload = ()=>{
        try {
          const canvas = document.createElement('canvas');
          canvas.width = img.width; canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img,0,0);
          const mime = `image/${targetFormat}`;
          let quality;
          if(targetFormat==='jpeg' || targetFormat==='webp'){
            const map = {quality:1.0, normal:0.85, low:0.70};
            quality = map[qualityPref] ?? 1.0;
          }
          canvas.toBlob(b=>{
            URL.revokeObjectURL(url);
            b?resolve(b):reject(new Error('toBlob 실패'));
          }, mime, quality);
        } catch(err){
          URL.revokeObjectURL(url);
          reject(err);
        }
      };
      img.onerror = ()=>{
        URL.revokeObjectURL(url);
        reject(new Error('이미지 로드 실패'));
      };
      img.src = url;
    })
  }

  async function processImageBlob(originalBlob, finalFormat){
    const tempJpeg = await convertToBlob(originalBlob, 'jpeg', 'quality');
    if(finalFormat==='jpeg'){
      return { blob: tempJpeg, format: 'jpeg' };
    }
    const finalBlob = await convertToBlob(tempJpeg, finalFormat, 'quality');
    return { blob: finalBlob, format: finalFormat };
  }

  async function processFiles(addToListOnly=false, autoDownload=false){
    const outFmt = document.getElementById('out-format').value;
    const prefix = document.getElementById('name-prefix').value.trim();
    if(state.files.length===0){ log('처리할 이미지를 먼저 선택하세요.','warn'); return; }

    log(`${state.files.length}개 이미지 처리 시작...`);
    let num = state.counterStart;
    const results = [];
    for(const file of state.files){
      try{
        const { blob, format } = await processImageBlob(file, outFmt);
        const baseName = prefix ? `${prefix} ${num}` : `${num}`;
        const filename = `${baseName}.${format}`;
        num++;
        results.push({ blob, filename });
        if(autoDownload){
          // FileSaver.js 라이브러리의 saveAs 함수를 사용
          saveAs(blob, filename);
        }
        log(`성공: ${filename}`,'ok');
      }catch(err){
        log(`오류 (${file.name}): ${err.message}`,'err');
      }
    }

    if(addToListOnly){
      state.results.push(...results);
      state.counterStart = num;
      renderList();
    }
    if(!addToListOnly && !autoDownload){
      // ZIP 다운로드
      const zip = new JSZip();
      results.forEach(r=> zip.file(r.filename, r.blob));
      const content = await zip.generateAsync({type:"blob"});
      saveAs(content, (prefix||'images')+".zip");
      log("ZIP 다운로드 완료",'ok');
    }
    state.files = [];
    log('모든 이미지 처리가 완료되었습니다.');
  }

  el('file-input').addEventListener('change', (e)=>{ onFilesPicked(e.target.files); e.target.value=''; })
  el('clear').addEventListener('click', ()=>{ state.files = []; state.results=[]; state.counterStart = 1; renderList(); log('목록이 비워졌습니다.'); })
  el('process-list').addEventListener('click', ()=> processFiles(true,false));

  // --- 여기부터 수정된 부분입니다 ---

  el('process-auto').addEventListener('click', () => {
      // 1. 처리된 결과 목록(state.results)이 있으면, 해당 목록의 파일들을 다운로드합니다.
      if (state.results.length > 0) {
          log(`처리된 목록의 이미지 ${state.results.length}개를 다운로드합니다.`, 'ok');
          state.results.forEach(r => saveAs(r.blob, r.filename));
          log('다운로드가 완료되었습니다.');
      } 
      // 2. 처리된 목록이 없으면, 기존처럼 선택된 파일(state.files)을 처리하고 바로 다운로드합니다.
      else {
          processFiles(false, true);
      }
  });

  el('process-zip').addEventListener('click', async () => {
      // 1. 처리된 결과 목록(state.results)이 있으면, 해당 목록을 ZIP으로 만들어 다운로드합니다.
      if (state.results.length > 0) {
          log(`처리된 목록의 이미지 ${state.results.length}개를 ZIP으로 다운로드합니다.`, 'ok');
          const prefix = el('name-prefix').value.trim();
          const zip = new JSZip();
          state.results.forEach(r => zip.file(r.filename, r.blob));
          const content = await zip.generateAsync({ type: "blob" });
          saveAs(content, (prefix || 'images') + ".zip");
          log('ZIP 다운로드 완료', 'ok');
      } 
      // 2. 처리된 목록이 없으면, 기존처럼 선택된 파일(state.files)을 처리하고 바로 ZIP으로 다운로드합니다.
      else {
          processFiles(false, false);
      }
  });

  // --- 여기까지 수정된 부분입니다 ---

  ;['dragenter','dragover'].forEach(ev=>{
    $drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); $drop.classList.add('dragover'); })
  })
  ;['dragleave','drop'].forEach(ev=>{
    $drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); $drop.classList.remove('dragover'); })
  })
  $drop.addEventListener('drop', e=>{ onFilesPicked(e.dataTransfer.files); })

  renderList();
  </script>
</body>
</html>