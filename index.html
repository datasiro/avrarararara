<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAI PNG 메타데이터 제거기 (자동/수동/ZIP 지원)</title>
  <style>
    /* (스타일 부분 동일, 생략) */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
  <header>
    <h1>NAI PNG 메타데이터 제거기</h1>
    <p class="lead">NovelAI 등에서 받은 PNG의 메타데이터를 <b>캔버스 재인코딩 → 최종 포맷</b> 방식으로 제거합니다.<br/>자동 다운로드 / 개별 다운로드 버튼 / ZIP 다운로드 모두 지원합니다.</p>
  </header>
  <div class="wrap">
    <div class="card">
      <!-- (UI 부분 동일, 생략) -->
    </div>
  </div>

  <footer>
    <p>모든 처리는 <b>브라우저 로컬</b>에서 수행됩니다.</p>
  </footer>

  <div id="loading-overlay" class="loading-overlay" style="display: none;">
    <div class="loading-box">
      <div class="spinner"></div>
      <div id="loading-text">이미지 로딩 중...</div>
    </div>
  </div>

  <script>
  if (!HTMLCanvasElement.prototype.toBlob) {
    HTMLCanvasElement.prototype.toBlob = function(callback, type, quality) {
      const dataURL = this.toDataURL(type, quality);
      const binStr = atob(dataURL.split(',')[1]);
      const len = binStr.length;
      const arr = new Uint8Array(len);
      for (let i = 0; i < len; i++) arr[i] = binStr.charCodeAt(i);
      callback(new Blob([arr], { type: type || 'image/png' }));
    };
  }

  const state = { files: [], counterStart: 1, results: [] }
  const el = (id)=>document.getElementById(id);
  const $drop = el('drop'), $list=el('list'), $log=el('log');

  const processButtons = ['process-list','process-auto','process-zip'].map(id=>el(id));
  function setButtonsDisabled(disabled){ processButtons.forEach(btn=>btn.disabled=disabled); }

  function log(msg, cls=""){
    const line = document.createElement('div');
    if(cls) line.className = cls;
    line.textContent = msg;
    $log.appendChild(line);
    $log.scrollTop = $log.scrollHeight;
  }

  function preloadImage(file){
    return new Promise((resolve,reject)=>{
      const img=new Image(); const url=URL.createObjectURL(file);
      img.onload=()=>{URL.revokeObjectURL(url); resolve(file);}
      img.onerror=()=>{URL.revokeObjectURL(url); reject(new Error(`'${file.name}'은(는) 유효한 이미지가 아닙니다.`));}
      img.src=url;
    })
  }

  async function onFilesPicked(files){
    const imageFiles=[...files].filter(f=>f.type.startsWith('image/'));
    if(imageFiles.length===0){ log('선택된 파일 중 이미지가 없습니다.','warn'); return; }

    const $loadingOverlay=el('loading-overlay'); const $loadingText=el('loading-text');
    $loadingOverlay.style.display='flex'; setButtonsDisabled(true);

    const total=imageFiles.length; const loaded=[];
    for(let i=0;i<total;i++){
      const file=imageFiles[i];
      $loadingText.textContent=`이미지 로딩 중... (${i+1}/${total})`;
      try{ await preloadImage(file); loaded.push(file);}catch(e){ log(e.message,'err'); }
    }

    state.files.push(...loaded);
    if(loaded.length>0){ log(`${loaded.length}개 이미지 추가됨.`,'ok'); }
    $loadingOverlay.style.display='none'; setButtonsDisabled(false);
  }

  function renderList(){
    $list.innerHTML='';
    if(state.results.length===0){
      $list.innerHTML='<div class="item" style="display:flex;align-items:center;justify-content:center;height:140px;color:var(--sub)">처리된 이미지가 없습니다.</div>'; return;
    }
    state.results.forEach(r=>{
      const card=document.createElement('div');card.className='item';
      const img=document.createElement('img');img.className='thumb'; img.src=URL.createObjectURL(r.blob);
      const meta=document.createElement('div');meta.className='meta'; meta.innerHTML=`<span>${r.filename}</span><span>${(r.blob.size/1024).toFixed(1)} KB</span>`;
      const actions=document.createElement('div');actions.className='actions';
      const btn=document.createElement('a');btn.href=img.src;btn.download=r.filename;btn.className='btn';btn.textContent='다운로드';
      actions.appendChild(btn);
      card.appendChild(img);card.appendChild(meta);card.appendChild(actions);
      $list.appendChild(card);
    })
  }

  function convertToBlob(sourceBlob,targetFormat,qualityPref='quality'){
    return new Promise((resolve,reject)=>{
      const img=new Image(); const url=URL.createObjectURL(sourceBlob);
      img.onload=()=>{
        try{
          const canvas=document.createElement('canvas');
          canvas.width=img.width; canvas.height=img.height;
          const ctx=canvas.getContext('2d'); ctx.drawImage(img,0,0);
          const mime=`image/${targetFormat}`;
          let quality;
          if(targetFormat==='jpeg'||targetFormat==='webp'){
            const map={quality:1.0,normal:0.85,low:0.70}; quality=map[qualityPref]??1.0;
          }
          canvas.toBlob(b=>{URL.revokeObjectURL(url); b?resolve(b):reject(new Error('toBlob 실패'));},mime,quality);
        }catch(err){URL.revokeObjectURL(url); reject(err);}
      }
      img.onerror=()=>{URL.revokeObjectURL(url); reject(new Error('이미지 로드 실패'));};
      img.src=url;
    })
  }

  // ✅ 수정된 버전: 임시 JPEG 거치지 않고 곧바로 변환
  async function processImageBlob(originalBlob, finalFormat){
    const finalBlob = await convertToBlob(originalBlob, finalFormat, 'quality');
    return { blob: finalBlob, format: finalFormat };
  }

  async function processSelectedImages(autoDownload=false, addToListOnly=false){
    if(state.files.length===0){ log("처리할 이미지를 먼저 선택하세요.","warn"); return; }

    log(`${state.files.length}개 이미지 처리 시작...`,"info");
    setButtonsDisabled(true);

    let num=state.counterStart;
    const outFmt=el('out-format').value;
    const prefix=el('name-prefix').value.trim();
    const results=[];

    for(const file of state.files){
      log(`- 처리 중: ${file.name}`,"info");
      try{
        const {blob,format}=await processImageBlob(file,outFmt);
        const baseName=prefix?`${prefix} ${num}`:`${num}`;
        const filename=`${baseName}.${format}`;
        num++;
        results.push({blob,filename});
        if(autoDownload){ saveAs(blob,filename); }
        log(`  성공: ${filename}`,"ok");
      }catch(err){ log(`  실패: ${file.name} (${err.message})`,"err"); }
    }

    if(addToListOnly){
      state.results.push(...results);
      state.counterStart=num;
      renderList();
    }else if(!autoDownload){
      const zip=new JSZip();
      results.forEach(r=>zip.file(r.filename,r.blob));
      const content=await zip.generateAsync({type:"blob"});
      saveAs(content,(prefix||"images")+".zip");
      log("ZIP 다운로드 완료","ok");
    }

    state.files=[];
    log("모든 이미지 처리가 완료되었습니다.","info");
    setButtonsDisabled(false);
  }

  // (이벤트 바인딩 부분 동일)
  </script>
</body>
</html>
